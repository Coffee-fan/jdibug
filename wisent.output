

*** Wisent jdibug-java-expr-wy.el - 2015-10-16 14:30



Useless nonterminals:

   dims_opt
   cast_expression


Terminals which are not used:

   PAREN_BLOCK
   BRACK_BLOCK
   SUPER


Useless rules:

#42    dims_opt:;
#43    dims_opt: dims;
#58    cast_expression: LPAREN primitive_type dims_opt RPAREN unary_expression;
#59    cast_expression: LPAREN name_with_opt_package RPAREN unary_expression_not_plus_minus;
#60    cast_expression: LPAREN name_with_opt_package dims RPAREN unary_expression_not_plus_minus;




Grammar

  Number, Rule
  1       $STARTS -> $expression
  2       $STARTS -> $dot_expression
  3       $expression -> $$expression expression
  4       $dot_expression -> $$dot_expression dot_expression
  5       literal -> NUMBER_LITERAL
  6       literal -> BOOLEAN_LITERAL
  7       literal -> STRING_LITERAL
  8       literal -> NULL_LITERAL
  9       primitive_type -> numeric_type
  10      primitive_type -> BOOLEAN
  11      numeric_type -> integral_type
  12      numeric_type -> floating_point_type
  13      integral_type -> BYTE
  14      integral_type -> SHORT
  15      integral_type -> INT
  16      integral_type -> LONG
  17      integral_type -> CHAR
  18      floating_point_type -> FLOAT
  19      floating_point_type -> DOUBLE
  20      reference_type -> class_or_interface_type
  21      reference_type -> array_type
  22      class_or_interface -> name_with_opt_package
  23      class_or_interface_type -> class_or_interface
  24      array_type -> primitive_type dims
  25      array_type -> name_with_opt_package dims
  26      name_with_opt_package -> simple_name
  27      name_with_opt_package -> qualified_name
  28      simple_name -> IDENTIFIER
  29      qualified_name -> name_with_opt_package DOT simple_name
  30      primary -> literal
  31      primary -> THIS
  32      primary -> LPAREN expression RPAREN
  33      primary -> dot_expression
  34      primary -> simple_name
  35      primary -> VOID DOT CLASS
  36      primary -> primitive_type DOT CLASS
  37      primary -> primitive_type dims DOT CLASS
  38      argument_list_opt -> /* empty */
  39      argument_list_opt -> argument_list
  40      argument_list -> expression
  41      argument_list -> argument_list COMMA expression
  44      dims -> LBRACK RBRACK
  45      dims -> dims LBRACK RBRACK
  46      dot_expression -> primary DOT IDENTIFIER LPAREN argument_list_opt RPAREN
  47      dot_expression -> primary DOT simple_name
  48      dot_expression -> primary DOT CLASS
  49      dot_expression -> array_access
  50      array_access -> primary LBRACK expression RBRACK
  51      postfix_expression -> primary
  52      unary_expression -> PLUS unary_expression
  53      unary_expression -> MINUS unary_expression
  54      unary_expression -> unary_expression_not_plus_minus
  55      unary_expression_not_plus_minus -> postfix_expression
  56      unary_expression_not_plus_minus -> COMP unary_expression
  57      unary_expression_not_plus_minus -> NOT unary_expression
  61      multiplicative_expression -> unary_expression
  62      multiplicative_expression -> multiplicative_expression MULT unary_expression
  63      multiplicative_expression -> multiplicative_expression DIV unary_expression
  64      multiplicative_expression -> multiplicative_expression MOD unary_expression
  65      additive_expression -> multiplicative_expression
  66      additive_expression -> additive_expression PLUS multiplicative_expression
  67      additive_expression -> additive_expression MINUS multiplicative_expression
  68      shift_expression -> additive_expression
  69      shift_expression -> shift_expression LSHIFT additive_expression
  70      shift_expression -> shift_expression RSHIFT additive_expression
  71      shift_expression -> shift_expression URSHIFT additive_expression
  72      relational_expression -> shift_expression
  73      relational_expression -> relational_expression LT shift_expression
  74      relational_expression -> relational_expression GT shift_expression
  75      relational_expression -> relational_expression LTEQ shift_expression
  76      relational_expression -> relational_expression GTEQ shift_expression
  77      instanceof_expression -> relational_expression
  78      instanceof_expression -> instanceof_expression INSTANCEOF reference_type
  79      equality_expression -> instanceof_expression
  80      equality_expression -> equality_expression EQEQ instanceof_expression
  81      equality_expression -> equality_expression NOTEQ instanceof_expression
  82      and_expression -> equality_expression
  83      and_expression -> and_expression AND equality_expression
  84      exclusive_or_expression -> and_expression
  85      exclusive_or_expression -> exclusive_or_expression XOR and_expression
  86      inclusive_or_expression -> exclusive_or_expression
  87      inclusive_or_expression -> inclusive_or_expression OR exclusive_or_expression
  88      conditional_and_expression -> inclusive_or_expression
  89      conditional_and_expression -> conditional_and_expression ANDAND inclusive_or_expression
  90      conditional_or_expression -> conditional_and_expression
  91      conditional_or_expression -> conditional_or_expression OROR conditional_and_expression
  92      conditional_expression -> conditional_or_expression
  93      conditional_expression -> conditional_or_expression QUESTION expression COLON conditional_expression
  94      expression -> conditional_expression


Terminals, with rules where they appear

$EOI (-1)
error (1)
PAREN_BLOCK (2)
BRACK_BLOCK (3)
LPAREN (4) 32 46 58 59 60
RPAREN (5) 32 46 58 59 60
LBRACK (6) 44 45 50
RBRACK (7) 44 45 50
NOT (8) 57
NOTEQ (9) 81
MOD (10) 64
AND (11) 83
ANDAND (12) 89
MULT (13) 62
PLUS (14) 52 66
COMMA (15) 41
MINUS (16) 53 67
DOT (17) 29 35 36 37 46 47 48
DIV (18) 63
COLON (19) 93
LT (20) 73
LSHIFT (21) 69
LTEQ (22) 75
EQEQ (23) 80
GT (24) 74
GTEQ (25) 76
RSHIFT (26) 70
URSHIFT (27) 71
QUESTION (28) 93
XOR (29) 85
OR (30) 87
OROR (31) 91
COMP (32) 56
NULL_LITERAL (33) 8
BOOLEAN_LITERAL (34) 6
IDENTIFIER (35) 28 46
STRING_LITERAL (36) 7
NUMBER_LITERAL (37) 5
BOOLEAN (38) 10
BYTE (39) 13
CHAR (40) 17
CLASS (41) 35 36 37 48
DOUBLE (42) 19
FLOAT (43) 18
INSTANCEOF (44) 78
INT (45) 15
LONG (46) 16
SHORT (47) 14
SUPER (48)
THIS (49) 31
VOID (50) 35
$$dot_expression (51) 4
$$expression (52) 3


Nonterminals, with rules where they appear

literal (53)
    on left: 5 6 7 8, on right: 30
primitive_type (54)
    on left: 9 10, on right: 24 36 37 58
numeric_type (55)
    on left: 11 12, on right: 9
integral_type (56)
    on left: 13 14 15 16 17, on right: 11
floating_point_type (57)
    on left: 18 19, on right: 12
reference_type (58)
    on left: 20 21, on right: 78
class_or_interface (59)
    on left: 22, on right: 23
class_or_interface_type (60)
    on left: 23, on right: 20
array_type (61)
    on left: 24 25, on right: 21
name_with_opt_package (62)
    on left: 26 27, on right: 22 25 29 59 60
simple_name (63)
    on left: 28, on right: 26 29 34 47
qualified_name (64)
    on left: 29, on right: 27
primary (65)
    on left: 30 31 32 33 34 35 36 37, on right: 46 47 48 50 51
argument_list_opt (66)
    on left: 38 39, on right: 46
argument_list (67)
    on left: 40 41, on right: 39 41
dims (68)
    on left: 44 45, on right: 24 25 37 43 45 60
dot_expression (69)
    on left: 46 47 48 49, on right: 4 33
array_access (70)
    on left: 50, on right: 49
postfix_expression (71)
    on left: 51, on right: 55
unary_expression (72)
    on left: 52 53 54, on right: 52 53 56 57 58 61 62 63 64
unary_expression_not_plus_minus (73)
    on left: 55 56 57, on right: 54 59 60
multiplicative_expression (74)
    on left: 61 62 63 64, on right: 62 63 64 65 66 67
additive_expression (75)
    on left: 65 66 67, on right: 66 67 68 69 70 71
shift_expression (76)
    on left: 68 69 70 71, on right: 69 70 71 72 73 74 75 76
relational_expression (77)
    on left: 72 73 74 75 76, on right: 73 74 75 76 77
instanceof_expression (78)
    on left: 77 78, on right: 78 79 80 81
equality_expression (79)
    on left: 79 80 81, on right: 80 81 82 83
and_expression (80)
    on left: 82 83, on right: 83 84 85
exclusive_or_expression (81)
    on left: 84 85, on right: 85 86 87
inclusive_or_expression (82)
    on left: 86 87, on right: 87 88 89
conditional_and_expression (83)
    on left: 88 89, on right: 89 90 91
conditional_or_expression (84)
    on left: 90 91, on right: 91 92 93
conditional_expression (85)
    on left: 92 93, on right: 93 94
expression (86)
    on left: 94, on right: 3 32 40 41 50 93
$dot_expression (87)
    on left: 4, on right: 2
$expression (88)
    on left: 3, on right: 1
$STARTS (89)
    on left: 1 2


state 0

    $$dot_expression	shift, and go to state 1
    $$expression	shift, and go to state 2

    $dot_expression	go to state 3
    $expression	go to state 4
    $STARTS	go to state 138



state 1

    $dot_expression  ->  $$dot_expression . dot_expression   (rule 4)

    LPAREN	shift, and go to state 5
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 27
    dot_expression	go to state 28
    array_access	go to state 29



state 2

    $expression  ->  $$expression . expression   (rule 3)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 44
    and_expression	go to state 45
    exclusive_or_expression	go to state 46
    inclusive_or_expression	go to state 47
    conditional_and_expression	go to state 48
    conditional_or_expression	go to state 49
    conditional_expression	go to state 50
    expression	go to state 51



state 3

    $STARTS  ->  $dot_expression .   (rule 2)

    $default	reduce using rule 2 ($STARTS)



state 4

    $STARTS  ->  $expression .   (rule 1)

    $default	reduce using rule 1 ($STARTS)



state 5

    primary  ->  LPAREN . expression RPAREN   (rule 32)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 44
    and_expression	go to state 45
    exclusive_or_expression	go to state 46
    inclusive_or_expression	go to state 47
    conditional_and_expression	go to state 48
    conditional_or_expression	go to state 49
    conditional_expression	go to state 50
    expression	go to state 52



state 6

    literal  ->  NULL_LITERAL .   (rule 8)

    $default	reduce using rule 8 (literal)



state 7

    literal  ->  BOOLEAN_LITERAL .   (rule 6)

    $default	reduce using rule 6 (literal)



state 8

    simple_name  ->  IDENTIFIER .   (rule 28)

    $default	reduce using rule 28 (simple_name)



state 9

    literal  ->  STRING_LITERAL .   (rule 7)

    $default	reduce using rule 7 (literal)



state 10

    literal  ->  NUMBER_LITERAL .   (rule 5)

    $default	reduce using rule 5 (literal)



state 11

    primitive_type  ->  BOOLEAN .   (rule 10)

    $default	reduce using rule 10 (primitive_type)



state 12

    integral_type  ->  BYTE .   (rule 13)

    $default	reduce using rule 13 (integral_type)



state 13

    integral_type  ->  CHAR .   (rule 17)

    $default	reduce using rule 17 (integral_type)



state 14

    floating_point_type  ->  DOUBLE .   (rule 19)

    $default	reduce using rule 19 (floating_point_type)



state 15

    floating_point_type  ->  FLOAT .   (rule 18)

    $default	reduce using rule 18 (floating_point_type)



state 16

    integral_type  ->  INT .   (rule 15)

    $default	reduce using rule 15 (integral_type)



state 17

    integral_type  ->  LONG .   (rule 16)

    $default	reduce using rule 16 (integral_type)



state 18

    integral_type  ->  SHORT .   (rule 14)

    $default	reduce using rule 14 (integral_type)



state 19

    primary  ->  THIS .   (rule 31)

    $default	reduce using rule 31 (primary)



state 20

    primary  ->  VOID . DOT CLASS   (rule 35)

    DOT	shift, and go to state 53



state 21

    primary  ->  literal .   (rule 30)

    $default	reduce using rule 30 (primary)



state 22

    primary  ->  primitive_type . DOT CLASS   (rule 36)
    primary  ->  primitive_type . dims DOT CLASS   (rule 37)

    LBRACK	shift, and go to state 54
    DOT	shift, and go to state 55

    dims	go to state 56



state 23

    primitive_type  ->  numeric_type .   (rule 9)

    $default	reduce using rule 9 (primitive_type)



state 24

    numeric_type  ->  integral_type .   (rule 11)

    $default	reduce using rule 11 (numeric_type)



state 25

    numeric_type  ->  floating_point_type .   (rule 12)

    $default	reduce using rule 12 (numeric_type)



state 26

    primary  ->  simple_name .   (rule 34)

    $default	reduce using rule 34 (primary)



state 27

    dot_expression  ->  primary . DOT IDENTIFIER LPAREN argument_list_opt RPAREN   (rule 46)
    dot_expression  ->  primary . DOT simple_name   (rule 47)
    dot_expression  ->  primary . DOT CLASS   (rule 48)
    array_access  ->  primary . LBRACK expression RBRACK   (rule 50)

    LBRACK	shift, and go to state 57
    DOT	shift, and go to state 58



state 28

    $dot_expression  ->  $$dot_expression dot_expression .   (rule 4)
    primary  ->  dot_expression .   (rule 33)

    $EOI	reduce using rule 4 ($dot_expression)
    $default	reduce using rule 33 (primary)


state 29

    dot_expression  ->  array_access .   (rule 49)

    $default	reduce using rule 49 (dot_expression)



state 30

    unary_expression_not_plus_minus  ->  NOT . unary_expression   (rule 57)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 59
    unary_expression_not_plus_minus	go to state 38



state 31

    unary_expression  ->  PLUS . unary_expression   (rule 52)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 60
    unary_expression_not_plus_minus	go to state 38



state 32

    unary_expression  ->  MINUS . unary_expression   (rule 53)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 61
    unary_expression_not_plus_minus	go to state 38



state 33

    unary_expression_not_plus_minus  ->  COMP . unary_expression   (rule 56)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 62
    unary_expression_not_plus_minus	go to state 38



state 34

    dot_expression  ->  primary . DOT IDENTIFIER LPAREN argument_list_opt RPAREN   (rule 46)
    dot_expression  ->  primary . DOT simple_name   (rule 47)
    dot_expression  ->  primary . DOT CLASS   (rule 48)
    array_access  ->  primary . LBRACK expression RBRACK   (rule 50)
    postfix_expression  ->  primary .   (rule 51)

    LBRACK	shift, and go to state 57
    DOT	shift, and go to state 58

    $default	reduce using rule 51 (postfix_expression)



state 35

    primary  ->  dot_expression .   (rule 33)

    $default	reduce using rule 33 (primary)



state 36

    unary_expression_not_plus_minus  ->  postfix_expression .   (rule 55)

    $default	reduce using rule 55 (unary_expression_not_plus_minus)



state 37

    multiplicative_expression  ->  unary_expression .   (rule 61)

    $default	reduce using rule 61 (multiplicative_expression)



state 38

    unary_expression  ->  unary_expression_not_plus_minus .   (rule 54)

    $default	reduce using rule 54 (unary_expression)



state 39

    multiplicative_expression  ->  multiplicative_expression . MULT unary_expression   (rule 62)
    multiplicative_expression  ->  multiplicative_expression . DIV unary_expression   (rule 63)
    multiplicative_expression  ->  multiplicative_expression . MOD unary_expression   (rule 64)
    additive_expression  ->  multiplicative_expression .   (rule 65)

    MOD	shift, and go to state 63
    MULT	shift, and go to state 64
    DIV	shift, and go to state 65

    $default	reduce using rule 65 (additive_expression)



state 40

    additive_expression  ->  additive_expression . PLUS multiplicative_expression   (rule 66)
    additive_expression  ->  additive_expression . MINUS multiplicative_expression   (rule 67)
    shift_expression  ->  additive_expression .   (rule 68)

    PLUS	shift, and go to state 66
    MINUS	shift, and go to state 67

    $default	reduce using rule 68 (shift_expression)



state 41

    shift_expression  ->  shift_expression . LSHIFT additive_expression   (rule 69)
    shift_expression  ->  shift_expression . RSHIFT additive_expression   (rule 70)
    shift_expression  ->  shift_expression . URSHIFT additive_expression   (rule 71)
    relational_expression  ->  shift_expression .   (rule 72)

    LSHIFT	shift, and go to state 68
    RSHIFT	shift, and go to state 69
    URSHIFT	shift, and go to state 70

    $default	reduce using rule 72 (relational_expression)



state 42

    relational_expression  ->  relational_expression . LT shift_expression   (rule 73)
    relational_expression  ->  relational_expression . GT shift_expression   (rule 74)
    relational_expression  ->  relational_expression . LTEQ shift_expression   (rule 75)
    relational_expression  ->  relational_expression . GTEQ shift_expression   (rule 76)
    instanceof_expression  ->  relational_expression .   (rule 77)

    LT	shift, and go to state 71
    LTEQ	shift, and go to state 72
    GT	shift, and go to state 73
    GTEQ	shift, and go to state 74

    $default	reduce using rule 77 (instanceof_expression)



state 43

    instanceof_expression  ->  instanceof_expression . INSTANCEOF reference_type   (rule 78)
    equality_expression  ->  instanceof_expression .   (rule 79)

    INSTANCEOF	shift, and go to state 75

    $default	reduce using rule 79 (equality_expression)



state 44

    equality_expression  ->  equality_expression . EQEQ instanceof_expression   (rule 80)
    equality_expression  ->  equality_expression . NOTEQ instanceof_expression   (rule 81)
    and_expression  ->  equality_expression .   (rule 82)

    NOTEQ	shift, and go to state 76
    EQEQ	shift, and go to state 77

    $default	reduce using rule 82 (and_expression)



state 45

    and_expression  ->  and_expression . AND equality_expression   (rule 83)
    exclusive_or_expression  ->  and_expression .   (rule 84)

    AND	shift, and go to state 78

    $default	reduce using rule 84 (exclusive_or_expression)



state 46

    exclusive_or_expression  ->  exclusive_or_expression . XOR and_expression   (rule 85)
    inclusive_or_expression  ->  exclusive_or_expression .   (rule 86)

    XOR	shift, and go to state 79

    $default	reduce using rule 86 (inclusive_or_expression)



state 47

    inclusive_or_expression  ->  inclusive_or_expression . OR exclusive_or_expression   (rule 87)
    conditional_and_expression  ->  inclusive_or_expression .   (rule 88)

    OR	shift, and go to state 80

    $default	reduce using rule 88 (conditional_and_expression)



state 48

    conditional_and_expression  ->  conditional_and_expression . ANDAND inclusive_or_expression   (rule 89)
    conditional_or_expression  ->  conditional_and_expression .   (rule 90)

    ANDAND	shift, and go to state 81

    $default	reduce using rule 90 (conditional_or_expression)



state 49

    conditional_or_expression  ->  conditional_or_expression . OROR conditional_and_expression   (rule 91)
    conditional_expression  ->  conditional_or_expression .   (rule 92)
    conditional_expression  ->  conditional_or_expression . QUESTION expression COLON conditional_expression   (rule 93)

    QUESTION	shift, and go to state 82
    OROR	shift, and go to state 83

    $default	reduce using rule 92 (conditional_expression)



state 50

    expression  ->  conditional_expression .   (rule 94)

    $default	reduce using rule 94 (expression)



state 51

    $expression  ->  $$expression expression .   (rule 3)

    $default	reduce using rule 3 ($expression)



state 52

    primary  ->  LPAREN expression . RPAREN   (rule 32)

    RPAREN	shift, and go to state 84



state 53

    primary  ->  VOID DOT . CLASS   (rule 35)

    CLASS	shift, and go to state 85



state 54

    dims  ->  LBRACK . RBRACK   (rule 44)

    RBRACK	shift, and go to state 86



state 55

    primary  ->  primitive_type DOT . CLASS   (rule 36)

    CLASS	shift, and go to state 87



state 56

    primary  ->  primitive_type dims . DOT CLASS   (rule 37)
    dims  ->  dims . LBRACK RBRACK   (rule 45)

    LBRACK	shift, and go to state 88
    DOT	shift, and go to state 89



state 57

    array_access  ->  primary LBRACK . expression RBRACK   (rule 50)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 44
    and_expression	go to state 45
    exclusive_or_expression	go to state 46
    inclusive_or_expression	go to state 47
    conditional_and_expression	go to state 48
    conditional_or_expression	go to state 49
    conditional_expression	go to state 50
    expression	go to state 90



state 58

    dot_expression  ->  primary DOT . IDENTIFIER LPAREN argument_list_opt RPAREN   (rule 46)
    dot_expression  ->  primary DOT . simple_name   (rule 47)
    dot_expression  ->  primary DOT . CLASS   (rule 48)

    IDENTIFIER	shift, and go to state 91
    CLASS	shift, and go to state 92

    simple_name	go to state 93



state 59

    unary_expression_not_plus_minus  ->  NOT unary_expression .   (rule 57)

    $default	reduce using rule 57 (unary_expression_not_plus_minus)



state 60

    unary_expression  ->  PLUS unary_expression .   (rule 52)

    $default	reduce using rule 52 (unary_expression)



state 61

    unary_expression  ->  MINUS unary_expression .   (rule 53)

    $default	reduce using rule 53 (unary_expression)



state 62

    unary_expression_not_plus_minus  ->  COMP unary_expression .   (rule 56)

    $default	reduce using rule 56 (unary_expression_not_plus_minus)



state 63

    multiplicative_expression  ->  multiplicative_expression MOD . unary_expression   (rule 64)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 94
    unary_expression_not_plus_minus	go to state 38



state 64

    multiplicative_expression  ->  multiplicative_expression MULT . unary_expression   (rule 62)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 95
    unary_expression_not_plus_minus	go to state 38



state 65

    multiplicative_expression  ->  multiplicative_expression DIV . unary_expression   (rule 63)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 96
    unary_expression_not_plus_minus	go to state 38



state 66

    additive_expression  ->  additive_expression PLUS . multiplicative_expression   (rule 66)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 97



state 67

    additive_expression  ->  additive_expression MINUS . multiplicative_expression   (rule 67)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 98



state 68

    shift_expression  ->  shift_expression LSHIFT . additive_expression   (rule 69)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 99



state 69

    shift_expression  ->  shift_expression RSHIFT . additive_expression   (rule 70)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 100



state 70

    shift_expression  ->  shift_expression URSHIFT . additive_expression   (rule 71)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 101



state 71

    relational_expression  ->  relational_expression LT . shift_expression   (rule 73)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 102



state 72

    relational_expression  ->  relational_expression LTEQ . shift_expression   (rule 75)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 103



state 73

    relational_expression  ->  relational_expression GT . shift_expression   (rule 74)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 104



state 74

    relational_expression  ->  relational_expression GTEQ . shift_expression   (rule 76)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 105



state 75

    instanceof_expression  ->  instanceof_expression INSTANCEOF . reference_type   (rule 78)

    IDENTIFIER	shift, and go to state 8
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18

    primitive_type	go to state 106
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    reference_type	go to state 107
    class_or_interface	go to state 108
    class_or_interface_type	go to state 109
    array_type	go to state 110
    name_with_opt_package	go to state 111
    simple_name	go to state 112
    qualified_name	go to state 113



state 76

    equality_expression  ->  equality_expression NOTEQ . instanceof_expression   (rule 81)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 114



state 77

    equality_expression  ->  equality_expression EQEQ . instanceof_expression   (rule 80)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 115



state 78

    and_expression  ->  and_expression AND . equality_expression   (rule 83)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 116



state 79

    exclusive_or_expression  ->  exclusive_or_expression XOR . and_expression   (rule 85)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 44
    and_expression	go to state 117



state 80

    inclusive_or_expression  ->  inclusive_or_expression OR . exclusive_or_expression   (rule 87)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 44
    and_expression	go to state 45
    exclusive_or_expression	go to state 118



state 81

    conditional_and_expression  ->  conditional_and_expression ANDAND . inclusive_or_expression   (rule 89)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 44
    and_expression	go to state 45
    exclusive_or_expression	go to state 46
    inclusive_or_expression	go to state 119



state 82

    conditional_expression  ->  conditional_or_expression QUESTION . expression COLON conditional_expression   (rule 93)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 44
    and_expression	go to state 45
    exclusive_or_expression	go to state 46
    inclusive_or_expression	go to state 47
    conditional_and_expression	go to state 48
    conditional_or_expression	go to state 49
    conditional_expression	go to state 50
    expression	go to state 120



state 83

    conditional_or_expression  ->  conditional_or_expression OROR . conditional_and_expression   (rule 91)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 44
    and_expression	go to state 45
    exclusive_or_expression	go to state 46
    inclusive_or_expression	go to state 47
    conditional_and_expression	go to state 121



state 84

    primary  ->  LPAREN expression RPAREN .   (rule 32)

    $default	reduce using rule 32 (primary)



state 85

    primary  ->  VOID DOT CLASS .   (rule 35)

    $default	reduce using rule 35 (primary)



state 86

    dims  ->  LBRACK RBRACK .   (rule 44)

    $default	reduce using rule 44 (dims)



state 87

    primary  ->  primitive_type DOT CLASS .   (rule 36)

    $default	reduce using rule 36 (primary)



state 88

    dims  ->  dims LBRACK . RBRACK   (rule 45)

    RBRACK	shift, and go to state 122



state 89

    primary  ->  primitive_type dims DOT . CLASS   (rule 37)

    CLASS	shift, and go to state 123



state 90

    array_access  ->  primary LBRACK expression . RBRACK   (rule 50)

    RBRACK	shift, and go to state 124



state 91

    simple_name  ->  IDENTIFIER .   (rule 28)
    dot_expression  ->  primary DOT IDENTIFIER . LPAREN argument_list_opt RPAREN   (rule 46)

    LPAREN	shift, and go to state 125

    $default	reduce using rule 28 (simple_name)



state 92

    dot_expression  ->  primary DOT CLASS .   (rule 48)

    $default	reduce using rule 48 (dot_expression)



state 93

    dot_expression  ->  primary DOT simple_name .   (rule 47)

    $default	reduce using rule 47 (dot_expression)



state 94

    multiplicative_expression  ->  multiplicative_expression MOD unary_expression .   (rule 64)

    $default	reduce using rule 64 (multiplicative_expression)



state 95

    multiplicative_expression  ->  multiplicative_expression MULT unary_expression .   (rule 62)

    $default	reduce using rule 62 (multiplicative_expression)



state 96

    multiplicative_expression  ->  multiplicative_expression DIV unary_expression .   (rule 63)

    $default	reduce using rule 63 (multiplicative_expression)



state 97

    multiplicative_expression  ->  multiplicative_expression . MULT unary_expression   (rule 62)
    multiplicative_expression  ->  multiplicative_expression . DIV unary_expression   (rule 63)
    multiplicative_expression  ->  multiplicative_expression . MOD unary_expression   (rule 64)
    additive_expression  ->  additive_expression PLUS multiplicative_expression .   (rule 66)

    MOD	shift, and go to state 63
    MULT	shift, and go to state 64
    DIV	shift, and go to state 65

    $default	reduce using rule 66 (additive_expression)



state 98

    multiplicative_expression  ->  multiplicative_expression . MULT unary_expression   (rule 62)
    multiplicative_expression  ->  multiplicative_expression . DIV unary_expression   (rule 63)
    multiplicative_expression  ->  multiplicative_expression . MOD unary_expression   (rule 64)
    additive_expression  ->  additive_expression MINUS multiplicative_expression .   (rule 67)

    MOD	shift, and go to state 63
    MULT	shift, and go to state 64
    DIV	shift, and go to state 65

    $default	reduce using rule 67 (additive_expression)



state 99

    additive_expression  ->  additive_expression . PLUS multiplicative_expression   (rule 66)
    additive_expression  ->  additive_expression . MINUS multiplicative_expression   (rule 67)
    shift_expression  ->  shift_expression LSHIFT additive_expression .   (rule 69)

    PLUS	shift, and go to state 66
    MINUS	shift, and go to state 67

    $default	reduce using rule 69 (shift_expression)



state 100

    additive_expression  ->  additive_expression . PLUS multiplicative_expression   (rule 66)
    additive_expression  ->  additive_expression . MINUS multiplicative_expression   (rule 67)
    shift_expression  ->  shift_expression RSHIFT additive_expression .   (rule 70)

    PLUS	shift, and go to state 66
    MINUS	shift, and go to state 67

    $default	reduce using rule 70 (shift_expression)



state 101

    additive_expression  ->  additive_expression . PLUS multiplicative_expression   (rule 66)
    additive_expression  ->  additive_expression . MINUS multiplicative_expression   (rule 67)
    shift_expression  ->  shift_expression URSHIFT additive_expression .   (rule 71)

    PLUS	shift, and go to state 66
    MINUS	shift, and go to state 67

    $default	reduce using rule 71 (shift_expression)



state 102

    shift_expression  ->  shift_expression . LSHIFT additive_expression   (rule 69)
    shift_expression  ->  shift_expression . RSHIFT additive_expression   (rule 70)
    shift_expression  ->  shift_expression . URSHIFT additive_expression   (rule 71)
    relational_expression  ->  relational_expression LT shift_expression .   (rule 73)

    LSHIFT	shift, and go to state 68
    RSHIFT	shift, and go to state 69
    URSHIFT	shift, and go to state 70

    $default	reduce using rule 73 (relational_expression)



state 103

    shift_expression  ->  shift_expression . LSHIFT additive_expression   (rule 69)
    shift_expression  ->  shift_expression . RSHIFT additive_expression   (rule 70)
    shift_expression  ->  shift_expression . URSHIFT additive_expression   (rule 71)
    relational_expression  ->  relational_expression LTEQ shift_expression .   (rule 75)

    LSHIFT	shift, and go to state 68
    RSHIFT	shift, and go to state 69
    URSHIFT	shift, and go to state 70

    $default	reduce using rule 75 (relational_expression)



state 104

    shift_expression  ->  shift_expression . LSHIFT additive_expression   (rule 69)
    shift_expression  ->  shift_expression . RSHIFT additive_expression   (rule 70)
    shift_expression  ->  shift_expression . URSHIFT additive_expression   (rule 71)
    relational_expression  ->  relational_expression GT shift_expression .   (rule 74)

    LSHIFT	shift, and go to state 68
    RSHIFT	shift, and go to state 69
    URSHIFT	shift, and go to state 70

    $default	reduce using rule 74 (relational_expression)



state 105

    shift_expression  ->  shift_expression . LSHIFT additive_expression   (rule 69)
    shift_expression  ->  shift_expression . RSHIFT additive_expression   (rule 70)
    shift_expression  ->  shift_expression . URSHIFT additive_expression   (rule 71)
    relational_expression  ->  relational_expression GTEQ shift_expression .   (rule 76)

    LSHIFT	shift, and go to state 68
    RSHIFT	shift, and go to state 69
    URSHIFT	shift, and go to state 70

    $default	reduce using rule 76 (relational_expression)



state 106

    array_type  ->  primitive_type . dims   (rule 24)

    LBRACK	shift, and go to state 54

    dims	go to state 126



state 107

    instanceof_expression  ->  instanceof_expression INSTANCEOF reference_type .   (rule 78)

    $default	reduce using rule 78 (instanceof_expression)



state 108

    class_or_interface_type  ->  class_or_interface .   (rule 23)

    $default	reduce using rule 23 (class_or_interface_type)



state 109

    reference_type  ->  class_or_interface_type .   (rule 20)

    $default	reduce using rule 20 (reference_type)



state 110

    reference_type  ->  array_type .   (rule 21)

    $default	reduce using rule 21 (reference_type)



state 111

    class_or_interface  ->  name_with_opt_package .   (rule 22)
    array_type  ->  name_with_opt_package . dims   (rule 25)
    qualified_name  ->  name_with_opt_package . DOT simple_name   (rule 29)

    LBRACK	shift, and go to state 54
    DOT	shift, and go to state 127

    $default	reduce using rule 22 (class_or_interface)

    dims	go to state 128



state 112

    name_with_opt_package  ->  simple_name .   (rule 26)

    $default	reduce using rule 26 (name_with_opt_package)



state 113

    name_with_opt_package  ->  qualified_name .   (rule 27)

    $default	reduce using rule 27 (name_with_opt_package)



state 114

    instanceof_expression  ->  instanceof_expression . INSTANCEOF reference_type   (rule 78)
    equality_expression  ->  equality_expression NOTEQ instanceof_expression .   (rule 81)

    INSTANCEOF	shift, and go to state 75

    $default	reduce using rule 81 (equality_expression)



state 115

    instanceof_expression  ->  instanceof_expression . INSTANCEOF reference_type   (rule 78)
    equality_expression  ->  equality_expression EQEQ instanceof_expression .   (rule 80)

    INSTANCEOF	shift, and go to state 75

    $default	reduce using rule 80 (equality_expression)



state 116

    equality_expression  ->  equality_expression . EQEQ instanceof_expression   (rule 80)
    equality_expression  ->  equality_expression . NOTEQ instanceof_expression   (rule 81)
    and_expression  ->  and_expression AND equality_expression .   (rule 83)

    NOTEQ	shift, and go to state 76
    EQEQ	shift, and go to state 77

    $default	reduce using rule 83 (and_expression)



state 117

    and_expression  ->  and_expression . AND equality_expression   (rule 83)
    exclusive_or_expression  ->  exclusive_or_expression XOR and_expression .   (rule 85)

    AND	shift, and go to state 78

    $default	reduce using rule 85 (exclusive_or_expression)



state 118

    exclusive_or_expression  ->  exclusive_or_expression . XOR and_expression   (rule 85)
    inclusive_or_expression  ->  inclusive_or_expression OR exclusive_or_expression .   (rule 87)

    XOR	shift, and go to state 79

    $default	reduce using rule 87 (inclusive_or_expression)



state 119

    inclusive_or_expression  ->  inclusive_or_expression . OR exclusive_or_expression   (rule 87)
    conditional_and_expression  ->  conditional_and_expression ANDAND inclusive_or_expression .   (rule 89)

    OR	shift, and go to state 80

    $default	reduce using rule 89 (conditional_and_expression)



state 120

    conditional_expression  ->  conditional_or_expression QUESTION expression . COLON conditional_expression   (rule 93)

    COLON	shift, and go to state 129



state 121

    conditional_and_expression  ->  conditional_and_expression . ANDAND inclusive_or_expression   (rule 89)
    conditional_or_expression  ->  conditional_or_expression OROR conditional_and_expression .   (rule 91)

    ANDAND	shift, and go to state 81

    $default	reduce using rule 91 (conditional_or_expression)



state 122

    dims  ->  dims LBRACK RBRACK .   (rule 45)

    $default	reduce using rule 45 (dims)



state 123

    primary  ->  primitive_type dims DOT CLASS .   (rule 37)

    $default	reduce using rule 37 (primary)



state 124

    array_access  ->  primary LBRACK expression RBRACK .   (rule 50)

    $default	reduce using rule 50 (array_access)



state 125

    dot_expression  ->  primary DOT IDENTIFIER LPAREN . argument_list_opt RPAREN   (rule 46)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    $default	reduce using rule 38 (argument_list_opt)

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    argument_list_opt	go to state 130
    argument_list	go to state 131
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 44
    and_expression	go to state 45
    exclusive_or_expression	go to state 46
    inclusive_or_expression	go to state 47
    conditional_and_expression	go to state 48
    conditional_or_expression	go to state 49
    conditional_expression	go to state 50
    expression	go to state 132



state 126

    array_type  ->  primitive_type dims .   (rule 24)
    dims  ->  dims . LBRACK RBRACK   (rule 45)

    LBRACK	shift, and go to state 88

    $default	reduce using rule 24 (array_type)



state 127

    qualified_name  ->  name_with_opt_package DOT . simple_name   (rule 29)

    IDENTIFIER	shift, and go to state 8

    simple_name	go to state 133



state 128

    array_type  ->  name_with_opt_package dims .   (rule 25)
    dims  ->  dims . LBRACK RBRACK   (rule 45)

    LBRACK	shift, and go to state 88

    $default	reduce using rule 25 (array_type)



state 129

    conditional_expression  ->  conditional_or_expression QUESTION expression COLON . conditional_expression   (rule 93)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 44
    and_expression	go to state 45
    exclusive_or_expression	go to state 46
    inclusive_or_expression	go to state 47
    conditional_and_expression	go to state 48
    conditional_or_expression	go to state 49
    conditional_expression	go to state 134



state 130

    dot_expression  ->  primary DOT IDENTIFIER LPAREN argument_list_opt . RPAREN   (rule 46)

    RPAREN	shift, and go to state 135



state 131

    argument_list_opt  ->  argument_list .   (rule 39)
    argument_list  ->  argument_list . COMMA expression   (rule 41)

    COMMA	shift, and go to state 136

    $default	reduce using rule 39 (argument_list_opt)



state 132

    argument_list  ->  expression .   (rule 40)

    $default	reduce using rule 40 (argument_list)



state 133

    qualified_name  ->  name_with_opt_package DOT simple_name .   (rule 29)

    $default	reduce using rule 29 (qualified_name)



state 134

    conditional_expression  ->  conditional_or_expression QUESTION expression COLON conditional_expression .   (rule 93)

    $default	reduce using rule 93 (conditional_expression)



state 135

    dot_expression  ->  primary DOT IDENTIFIER LPAREN argument_list_opt RPAREN .   (rule 46)

    $default	reduce using rule 46 (dot_expression)



state 136

    argument_list  ->  argument_list COMMA . expression   (rule 41)

    LPAREN	shift, and go to state 5
    NOT	shift, and go to state 30
    PLUS	shift, and go to state 31
    MINUS	shift, and go to state 32
    COMP	shift, and go to state 33
    NULL_LITERAL	shift, and go to state 6
    BOOLEAN_LITERAL	shift, and go to state 7
    IDENTIFIER	shift, and go to state 8
    STRING_LITERAL	shift, and go to state 9
    NUMBER_LITERAL	shift, and go to state 10
    BOOLEAN	shift, and go to state 11
    BYTE	shift, and go to state 12
    CHAR	shift, and go to state 13
    DOUBLE	shift, and go to state 14
    FLOAT	shift, and go to state 15
    INT	shift, and go to state 16
    LONG	shift, and go to state 17
    SHORT	shift, and go to state 18
    THIS	shift, and go to state 19
    VOID	shift, and go to state 20

    literal	go to state 21
    primitive_type	go to state 22
    numeric_type	go to state 23
    integral_type	go to state 24
    floating_point_type	go to state 25
    simple_name	go to state 26
    primary	go to state 34
    dot_expression	go to state 35
    array_access	go to state 29
    postfix_expression	go to state 36
    unary_expression	go to state 37
    unary_expression_not_plus_minus	go to state 38
    multiplicative_expression	go to state 39
    additive_expression	go to state 40
    shift_expression	go to state 41
    relational_expression	go to state 42
    instanceof_expression	go to state 43
    equality_expression	go to state 44
    and_expression	go to state 45
    exclusive_or_expression	go to state 46
    inclusive_or_expression	go to state 47
    conditional_and_expression	go to state 48
    conditional_or_expression	go to state 49
    conditional_expression	go to state 50
    expression	go to state 137



state 137

    argument_list  ->  argument_list COMMA expression .   (rule 41)

    $default	reduce using rule 41 (argument_list)



state 138

    $EOI	shift, and go to state 139



state 139

    $EOI	shift, and go to state 140



state 140

    $default	accept
